# Какие файлы есть
* `dp.cpp` -- решение с помощью динамического программирования, для проверки ответа
* `single.cpp` -- однопоточный перебор по инструкции из чата
* `v1.cpp` -- первый вариант многопоточного решения, более удачный (проигрывает всего в 2-3 раза однопоточному (на 100 элементах)
* `v2.cpp` -- второй вариант многопоточного решения, менее удачный (не смог дождаться на 100 элементах, поэтому рассматриваться не будет)
* `dp.cpp` -- решение динамическим программированием, для проверки корректности ответа
* `Makefile` -- чтобы все это скомпилить. `make` -- все собрать, `make tsan` -- собрать v1 и v2 с thread sanitizer,  `make clean` - удалить бинарники.
* `gen_tests.py` -- генератор тестов, реально не используется.
* `draw_graphs.py` -- рисовалка графиков по захардкоженным значениям. Использовал в конце для создания крафиков и все.

# Реализованный алгоритм
Однопоточный был описан в чате:

Отсортировали по удельной стоимости.

Поддерживаем последний элемент, который точно берем. Пытаемся жадно набирать предметы пока можем. Это оценка снизу. Оценка сверху - добавить к нему долю следующего предмета, которую мы могли бы взять, если бы могли резать (округляем вниз потому что известно, что ответ целый)

Как это параллелить:

По сути у нас каждый таск генерит набор следующих тасков. Осталось их грамотно распределить по потокам.

Будем поддерживать атомарный счетчик запущенных и работающих потоков.

Как только какой-то поток закончил свои задачи, он завершается.

Если кто-то, у кого еще есть задачи, видит, что есть свободные потоки, он отдает половину своих задач ему.

# Как запускалось
На абсоютно разгруженной системе.

Процессор `Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz`.

Hardware concurrency 8.

# Результаты
Не смог даже приблизиться к однопоточному решению (`single`)

Результат запуска:
![Run](Pictures/launch_results.png)

Ускорение (точнее проигрыш, потому что меньше 1) на маленьких тестах(`v1`):

![small](Pictures/small_increase.png)

Проигрыш на больших тестах:

![small](Pictures/large_increase.png)

Проигрыш `v2` на маленьких тестах:

![small](Pictures/small_v2_increase.png)

Итого `v1` всего в 4 раза медленнее!!!
Скорее всего на кластерах или Xeon или i9 процессорах будет даже выигрыш.
